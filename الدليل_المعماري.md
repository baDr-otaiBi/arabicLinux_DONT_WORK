# الدليل المعماري الشامل

<div dir="rtl">

## مقدمة

يقدم هذا الدليل شرحاً معمارياً متعمقاً لتوزيعة لينكس العربية، موضحاً الأسس التقنية والفلسفية التي بُنيت عليها التوزيعة. الهدف هو توفير فهم شامل للبنية المعمارية وكيفية تفاعل المكونات المختلفة مع بعضها البعض.

## الفلسفة المعمارية

### ١. النموذج الطبقي (Layered Architecture)

تتبع التوزيعة نموذجاً طبقياً هرمياً يفصل المسؤوليات ويحقق التجريد:

```
┌─────────────────────────────────────────────┐
│  طبقة التطبيقات (Application Layer)        │  ← /تطبيقات
│  البرامج التطبيقية والأدوات الإدارية       │
├─────────────────────────────────────────────┤
│  طبقة المستخدم (User Space Layer)          │  ← /مستخدم
│  بيئات المستخدمين والبيانات الشخصية        │
├─────────────────────────────────────────────┤
│  طبقة التكوين (Configuration Layer)        │  ← /إعدادات
│  ملفات الضبط والإعدادات                    │
├─────────────────────────────────────────────┤
│  طبقة المكتبات (Library Layer)             │  ← /مكتبات
│  المكتبات المشتركة والموارد                │
├─────────────────────────────────────────────┤
│  طبقة النظام (System Layer)                │  ← /نظام
│  المكونات الأساسية والخدمات الجوهرية        │
├─────────────────────────────────────────────┤
│  طبقة الإقلاع (Boot Layer)                 │  ← /إقلاع
│  آليات بدء التشغيل والتهيئة الأولية        │
├─────────────────────────────────────────────┤
│  طبقة الأجهزة (Hardware Abstraction Layer) │  ← /أجهزة
│  واجهات التعامل مع العتاد المادي            │
└─────────────────────────────────────────────┘
           ↓
    [ العتاد المادي (Hardware) ]
```

### ٢. مبدأ الفصل بين الاهتمامات (Separation of Concerns)

كل مجلد رئيسي يعالج اهتماماً محدداً:
- **العزل الوظيفي**: عدم تداخل المسؤوليات
- **الاستقلالية**: إمكانية تطوير كل طبقة بشكل مستقل
- **قابلية الاختبار**: سهولة اختبار كل مكون على حدة

### ٣. مبدأ التجريد التصاعدي (Progressive Abstraction)

من المستوى المنخفض (العتاد) إلى المستوى العالي (التطبيقات):
- **تبسيط التعقيد**: إخفاء التفاصيل المعقدة خلف واجهات بسيطة
- **إعادة الاستخدام**: بناء مكونات عالية المستوى على مكونات منخفضة المستوى
- **قابلية الصيانة**: تغيير التنفيذ الداخلي دون التأثير على الواجهة

## المكونات الأساسية والتفاعل بينها

### تدفق عملية الإقلاع (Boot Flow)

```
[تشغيل الجهاز]
     ↓
[BIOS/UEFI] → فحص العتاد الأساسي (POST)
     ↓
[محمل الإقلاع - Bootloader] → GRUB/systemd-boot
     ↓
[تحميل النواة - Kernel Loading] → من /إقلاع
     ↓
[تهيئة النواة - Kernel Initialization]
     ├─→ تحميل برامج التشغيل من /مكتبات/نواة
     ├─→ كشف الأجهزة وإنشاء /أجهزة
     └─→ تحميل نظام الملفات الجذر
     ↓
[تنفيذ /إقلاع/بدء_النظام.sh]
     ├─→ قراءة /نظام/معلومات_النظام.conf
     ├─→ تحميل /إعدادات/إعدادات_النظام.conf
     ├─→ التحقق من بنية المجلدات
     └─→ تهيئة الخدمات الأساسية
     ↓
[بدء الخدمات - Service Initialization]
     ├─→ تحميل الخدمات من /تطبيقات
     └─→ تطبيق التكوينات من /إعدادات
     ↓
[تهيئة بيئة المستخدم - User Space Setup]
     └─→ تحضير /مستخدم للدخول
     ↓
[جاهز للاستخدام - System Ready]
```

### دورة حياة التطبيق (Application Lifecycle)

```
[تشغيل التطبيق]
     ↓
1. قراءة التكوينات
   ├─→ /إعدادات/تطبيقات/[اسم_التطبيق].conf
   └─→ ~/.config/[اسم_التطبيق]/ (من /مستخدم)
     ↓
2. تحميل المكتبات الديناميكية
   ├─→ ld.so يبحث في /مكتبات/مشتركة
   ├─→ تحليل التبعيات (ldd)
   └─→ ربط الرموز (Symbol Resolution)
     ↓
3. الوصول إلى الموارد
   ├─→ قراءة/كتابة الملفات في /مستخدم
   ├─→ التواصل مع الأجهزة عبر /أجهزة
   └─→ استخدام الخدمات من /نظام
     ↓
4. التنفيذ
   ├─→ معالجة البيانات
   ├─→ التفاعل مع المستخدم
   └─→ كتابة السجلات
     ↓
5. الإنهاء
   ├─→ تحرير الموارد
   ├─→ حفظ الحالة
   └─→ إغلاق الملفات والاتصالات
```

## الأنماط المعمارية المطبقة (Architectural Patterns)

### ١. نمط المستودع (Repository Pattern)

المجلدات تعمل كمستودعات للموارد:
- **/مكتبات**: مستودع للمكتبات المشتركة
- **/إعدادات**: مستودع للتكوينات
- **/تطبيقات**: مستودع للبرامج التنفيذية

### ٢. نمط الطبقات (Layered Pattern)

فصل واضح بين الطبقات مع اتجاه تبعية واحد:
- الطبقات العليا تعتمد على الطبقات السفلى
- الطبقات السفلى لا تعرف شيئاً عن الطبقات العليا

### ٣. نمط الأنابيب والمرشحات (Pipes and Filters)

في سطر الأوامر:
```bash
cat /نظام/معلومات_النظام.conf | grep "الإصدار" | awk '{print $2}'
     ↓                              ↓                ↓
   مصدر                          مرشح             معالج
```

### ٤. نمط الموزع (Distributed Pattern)

في الأنظمة الشبكية:
- خدمات موزعة عبر الشبكة
- تواصل عبر بروتوكولات معيارية (SSH, HTTP, NFS)

## البنية التقنية المتقدمة

### نظام الملفات الافتراضي (Virtual File System - VFS)

VFS هو طبقة التجريد التي توحد التعامل مع أنظمة الملفات المختلفة:

```
تطبيق
   ↓ (استدعاءات النظام: open, read, write, close)
[VFS - طبقة التجريد الموحدة]
   ↓ (عمليات عامة)
   ├─→ ext4 (للأقراص المحلية)
   ├─→ NFS (للملفات الشبكية)
   ├─→ procfs (ملفات افتراضية)
   ├─→ sysfs (معلومات النواة)
   └─→ tmpfs (ملفات في الذاكرة)
```

### مدير الذاكرة الافتراضية (Virtual Memory Manager)

```
[فضاء عناوين العملية - Process Address Space]
   ├─→ قطاع النص (Text Segment) - شيفرة البرنامج
   │   └─→ محمي للقراءة والتنفيذ فقط (r-x)
   │
   ├─→ قطاع البيانات (Data Segment) - متغيرات عامة
   │   └─→ قابل للقراءة والكتابة (rw-)
   │
   ├─→ الكومة (Heap) - التخصيص الديناميكي (malloc)
   │   └─→ ينمو للأعلى ↑
   │
   ├─→ المكدس (Stack) - متغيرات محلية واستدعاءات دوال
   │   └─→ ينمو للأسفل ↓
   │
   └─→ المكتبات المشتركة - من /مكتبات
       └─→ محملة في عناوين عشوائية (ASLR)
```

### جدولة العمليات (Process Scheduling)

خوارزميات الجدولة في النواة:

#### CFS (Completely Fair Scheduler)
```
المبدأ: كل عملية تحصل على حصة عادلة من CPU

الآلية:
1. الشجرة الحمراء-السوداء (Red-Black Tree) لترتيب العمليات
2. vruntime: الوقت الافتراضي لتنفيذ العملية
3. اختيار العملية بأقل vruntime

الأولويات:
- nice values: -20 (أعلى) إلى +19 (أدنى)
- real-time priorities: 0-99
```

#### Real-Time Scheduling Classes
- **SCHED_FIFO**: First-In-First-Out للمهام الحرجة زمنياً
- **SCHED_RR**: Round-Robin مع فترات زمنية
- **SCHED_DEADLINE**: جدولة بناءً على المواعيد النهائية

### نظام إدارة الحزم (Package Management System)

```
[المستودع - Repository]
     ↓
[قاعدة بيانات الحزم - Package Database]
   ├─→ البيانات الوصفية (Metadata)
   │   ├─→ الاسم، الإصدار، الوصف
   │   ├─→ التبعيات (Dependencies)
   │   └─→ التعارضات (Conflicts)
   │
   └─→ قائمة الملفات (File List)
       ├─→ الملفات التنفيذية → /تطبيقات
       ├─→ المكتبات → /مكتبات
       ├─→ التكوينات → /إعدادات
       └─→ الوثائق → /usr/share/doc
```

عملية التثبيت:
```
1. حل التبعيات (Dependency Resolution)
   └─→ خوارزمية SAT Solver

2. التحميل (Download)
   └─→ التحقق من التوقيع الرقمي (GPG)

3. فك الضغط (Extraction)
   └─→ tar.xz أو tar.gz

4. التنفيذ (Installation)
   ├─→ نسخ الملفات
   ├─→ إنشاء الروابط
   └─→ تشغيل سكربتات ما بعد التثبيت (post-install)

5. التسجيل (Registration)
   └─→ تحديث قاعدة البيانات المحلية
```

## الأمان والحماية (Security Architecture)

### نموذج الأمان متعدد الطبقات (Multi-Layered Security Model)

```
┌──────────────────────────────────────┐
│  المستخدم (User Authentication)      │
│  └─→ PAM, 2FA, Biometrics           │
├──────────────────────────────────────┤
│  التطبيقات (Application Security)    │
│  └─→ Sandboxing, AppArmor, Flatpak  │
├──────────────────────────────────────┤
│  نظام الملفات (Filesystem Security)  │
│  └─→ Permissions, ACLs, Encryption  │
├──────────────────────────────────────┤
│  النواة (Kernel Security)            │
│  └─→ SELinux, Capabilities, ASLR    │
├──────────────────────────────────────┤
│  العتاد (Hardware Security)          │
│  └─→ TPM, Secure Boot, IOMMU        │
└──────────────────────────────────────┘
```

### Linux Security Modules (LSM)

إطار عمل موحد لأنظمة الأمان:

#### SELinux (Security-Enhanced Linux)
```
المبدأ: Mandatory Access Control (MAC)

السياسات:
- Type Enforcement: كل كائن له نوع (type)
- Role-Based Access Control: أدوار للمستخدمين
- Multi-Level Security: مستويات سرية

السياق الأمني:
user:role:type:level
system_u:object_r:user_home_t:s0
```

#### AppArmor
```
المبدأ: Path-based Access Control

الملفات الشخصية (Profiles):
- complain mode: تسجيل المخالفات فقط
- enforce mode: منع المخالفات

مثال:
/usr/bin/firefox {
  /مستخدم/*/التنزيلات/** rw,
  /etc/hosts r,
  deny /etc/shadow rw,
}
```

### التشفير (Cryptography)

#### تشفير القرص الكامل (Full Disk Encryption)
```
LUKS (Linux Unified Key Setup)

الطبقات:
[القسم المشفر]
     ↓
[رأسية LUKS] → يحوي المعلومات الوصفية ومفاتيح التشفير
     ↓
[dm-crypt] → طبقة التشفير في kernel
     ↓
[نظام الملفات] → ext4, btrfs, xfs
```

خوارزميات التشفير:
- **AES-XTS**: للأقراص (256-bit)
- **ChaCha20-Poly1305**: بديل حديث
- **Argon2**: لتوليد المفاتيح من كلمة المرور

#### التشفير على مستوى الملفات
- **eCryptfs**: تشفير شفاف للمجلدات الشخصية
- **fscrypt**: تشفير محلي في نظام الملفات (ext4, f2fs)

## الأداء والتحسين (Performance Optimization)

### استراتيجيات التخزين المؤقت (Caching Strategies)

#### Page Cache
```
الذاكرة الفيزيائية (Physical Memory)
   ├─→ نشطة (Active): الصفحات المستخدمة حديثاً
   ├─→ غير نشطة (Inactive): صفحات قديمة
   └─→ حرة (Free): ذاكرة متاحة

السياسات:
- LRU (Least Recently Used): إخراج الأقل استخداماً
- ARC (Adaptive Replacement Cache): تكيفي
```

#### Inode Cache & Dentry Cache
```
Dentry Cache: ذاكرة مؤقتة للمسارات
  /مستخدم/أحمد/المستندات/ملف.txt
  └─→ تسريع البحث في الدلائل

Inode Cache: ذاكرة مؤقتة لمعلومات الملفات
  └─→ تجنب قراءة القرص لكل عملية stat()
```

### التحسينات على مستوى الإدخال/الإخراج (I/O Optimizations)

#### Read-Ahead
```
القراءة المسبقة للبيانات:
- اكتشاف الأنماط التسلسلية
- تحميل البيانات المتوقعة مسبقاً
- تقليل زمن الوصول (Latency)
```

#### Write-Back Caching
```
الكتابة إلى الذاكرة أولاً:
1. التطبيق يكتب → Page Cache
2. وضع علامة "dirty" على الصفحة
3. pdflush/kworker يكتب إلى القرص لاحقاً
4. التحكم في التوقيت عبر /proc/sys/vm/dirty_*
```

### التحسين على مستوى المعالج (CPU Optimizations)

#### NUMA (Non-Uniform Memory Access)
```
في الأنظمة متعددة المعالجات:
- كل معالج له ذاكرته المحلية
- الوصول للذاكرة المحلية أسرع
- التخصيص الذكي للذاكرة والعمليات
```

#### CPU Affinity
```
ربط العمليات بمعالجات محددة:
- تحسين استخدام Cache
- تقليل التبديل بين المعالجات (Context Switches)

الأوامر:
taskset -c 0,1 ./برنامج  # تشغيل على CPU 0 و 1
```

## قابلية التوسع والحوسبة السحابية (Scalability & Cloud Computing)

### الحاويات (Containers)

```
[مضيف النظام - Host System]
   └─→ [النواة المشتركة]
        ├─→ [حاوية 1] - عزل بـ namespaces + cgroups
        │   ├─→ PID namespace
        │   ├─→ Network namespace
        │   ├─→ Mount namespace
        │   └─→ User namespace
        │
        ├─→ [حاوية 2]
        └─→ [حاوية 3]

مقارنة بالآلات الافتراضية:
الحاويات: خفيفة، سريعة، نفس النواة
VMs: عزل كامل، أبطأ، نواة منفصلة
```

### تنسيق الحاويات (Container Orchestration)

Kubernetes المعرّب:
```
- العناقيد (Clusters): مجموعة من الخوادم
- الحبات (Pods): أصغر وحدة نشر
- الخدمات (Services): نقاط الوصول للتطبيقات
- الأحجام الدائمة (Persistent Volumes): التخزين
```

## المستقبل والتطوير (Future Development)

### تقنيات ناشئة

#### eBPF (Extended Berkeley Packet Filter)
```
برمجة آمنة للنواة:
- مراقبة الأداء بدون overhead
- جدار حماية على مستوى النواة
- تتبع النظام المتقدم
```

#### io_uring
```
واجهة إدخال/إخراج عالية الأداء:
- عمليات غير متزامنة (Async I/O)
- تقليل استدعاءات النظام
- تحسين كبير في الأداء
```

### التوجه نحو الحوسبة الطرفية (Edge Computing)
- أنظمة مضمنة (Embedded Systems)
- إنترنت الأشياء (IoT)
- الحوسبة الضبابية (Fog Computing)

</div>
